---
title: "Assignment 2"
author: "Frank Moeller"
---

# Remaining Questions

# Assignment 2

## Concept

-   2 actors interact (**interaction function**) exchange their wealth (**transaction function**)

## Implementation

### Initial Population distribution

```{r}
N<- 5000 # define N as default population size

MU<- 100 # define MU as the default population mean

population <- rnorm(N, mean = MU_1, sd = MU/5) # define the dataframe "population" as a normally distributed set of size "N" (5000) with a mean "M" (100$) and a sd of "MU/5" (20$) 

##is this a dataframe?
```

-   Gaussian (normal) distribution

-   dependent variable = simoleons (\$)

### Visualization

#### Measure

-   Gini coefficient (measure of equality)

    -   0=equality

    -   1=inequality

    -   ! Usually assessed for income, here wealth

```{r}
gini<- function(y) { 
# measure of equality (0=equality, 1=inequality) applied for wealth [usually for income]
y<- sort(y) #puts vector (wealth) of the dataframe in order
n<- length(y) #assess the lenght of the vector (individuals) in the dataframe 
## Question does length define the number of individuals?
numer<- 2*sum((1:n)*y)#defines the numerator of the formular
#sum(start value:end value)
#summs the sorted vecotr (wealth) of the dataframe and multiplies by 2

denom<- n*sum(y)#defines the denominator of the formular
#multiplies the number of participants by the sum of the wealth  

return ((numer/denom)-(n+1)/n)
#puts the formula together
}
```

#### Apply

```{r}
gini(population)
```

reference output: \~0.113

#### Define hist

```{r}
#install.packages("ggplot2")
library(ggplot2)
hist_custom<- function(popuation, label = 'pop',...) {
label <- paste0(label,": G", round(gini(population), 2))
# add and calculate the little gini coefficient in the top right corner

population_df<- data.frame(population = population)
#

ggplot(population_df, aes(x = population))+
  geom_histogram(bin=30,fill='blue',alpha=0.5,...)+
  labs(title=label,x='Wealth',y='Count')+
  theme_minimal()+
  theme(legend.position="none")
}
```

#### Visualize

```{r}
hist_custom(population)
```

### Transactions

#### Define Wealth-Conserving Transaction

```{r}
random_split<- function(A, B) {
  pot<- A+B #sum the wealth of the agent A and B
  share<- runif(1,min=0,max=pot)
  #define conditions for sharing (here all possible conditions)
  return(c(share,pot-share))
  #put formula together
  #one recives the share one the remaining wealth
  
  #A and B are undefined, insert their wealth to run the function
}
```

#### Apply

```{r}
random_split(100, 100)
```

reference output: \~(39.322, 160.678)

= sum should never exceed 200

### Interactions

```{r}
anyone<- function(N)
{
  return(sample(0:(N-1),2))
  #From N (number of agents) a sample of 2 participants is drawn at random
  }
```

```{r}
anyone(N)
```

reference output: \[1593, 1439\]

=draws 2 random numbers from 1-N

### Simulation

#### Define

```{r}
step<-function(population, transaction=random_split, interaction=anyone)
  {
  #translate the defined functions into meaningfull names
  i_j<- interaction(length(population))
  i<- i_j[1]
  j<- i_j[2]
  #draw two agents called i & j
  population[c(i, j)]<- transaction(population[i],population[j])
  #run the transaction between the two agents and adjust their wealth according to the transaction
  return (population)
}

simulate<- function(population,T,step_func=step,transaction=random_split, interaction=anyone) 
{
   #simulate the interactions over T steps
  ##define T ???
  pop_copy<-population
  #create a copy of population
  
  result<- list(pop_copy)
  ## why ???
  
  for (t in 1:T) 
  {
    pop_copy<- step_func(pop_copy, transaction, interaction)
    result[[t+1]]<- pop_copy
  }
  return (result)
}
```

#### Run

```{r}
testpopulation<- rep(100,4)
#create testpopulation of 4 individuals, with 100$ each

result<- simulate(testpopulation, 8)
#simulate the population over 8 steps

for(pop in result)
{
  print(pop)
}
```

ERROR: "Warning: NAs produced"

#### Visualize

```{r}

```
